-- -------------------------------------------------------------
-- 
-- File Name: /u/home/eraguzin/matlab/LNspec/matlab/codegen/deinterlace__instance_12_/hdlsrc/deinterlace_instance_12_fixpt.vhd
-- Created: 2023-01-17 10:41:19
-- 
-- Generated by MATLAB 9.12, MATLAB Coder 5.4 and HDL Coder 3.20
-- Reworked by Eric Raguzin
-- 5/18/2023
-- 
-- -------------------------------------------------------------
-- Rate and Clocking Details
-- -------------------------------------------------------------
-- Design base rate: 1
-- 
-- 
-- Clock Enable  Sample Time
-- -------------------------------------------------------------
-- ce_out        1
-- -------------------------------------------------------------
-- 
-- 
-- Output Signal                 Clock Enable  Sample Time
-- -------------------------------------------------------------
-- ch1_val_re                    ce_out        1
-- ch1_val_im                    ce_out        1
-- ch2_val_re                    ce_out        1
-- ch2_val_im                    ce_out        1
-- bin                           ce_out        1
-- ready                         ce_out        1
-- -------------------------------------------------------------
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: deinterlace_instance_12_fixpt
-- Source Path: deinterlace__instance_12__fixpt
-- Hierarchy Level: 0
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;

--Note that whatever bit representation the values come in as, there's an extra implied 0 at the end of the output
ENTITY deinterlace_instance_12_fixpt IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        clk_enable                        :   IN    std_logic;
        fft_val_re                        :   IN    std_logic_vector(31 DOWNTO 0);  -- sfix32_En7
        fft_val_im                        :   IN    std_logic_vector(31 DOWNTO 0);  -- sfix32_En7
        fft_valid                         :   IN    std_logic;
        ce_out                            :   OUT   std_logic;
        ch1_val_re                        :   OUT   std_logic_vector(31 DOWNTO 0);  -- sfix32_En8
        ch1_val_im                        :   OUT   std_logic_vector(31 DOWNTO 0);  -- sfix32_En8
        ch2_val_re                        :   OUT   std_logic_vector(31 DOWNTO 0);  -- sfix32_En8
        ch2_val_im                        :   OUT   std_logic_vector(31 DOWNTO 0);  -- sfix32_En8
        bin                               :   OUT   std_logic_vector(12 DOWNTO 0);  -- ufix13
        ready                             :   OUT   std_logic
        );
END deinterlace_instance_12_fixpt;


ARCHITECTURE rtl OF deinterlace_instance_12_fixpt IS

  -- Component Declarations
  component PF_TPSRAM_C1
    PORT ( 
        CLK                               :   IN    std_logic;
        R_ADDR                            :   IN    std_logic_vector(10 downto 0);
        W_EN                              :   IN    std_logic;
        W_ADDR                            :   IN    std_logic_vector(10 downto 0);
        W_DATA                            :   IN    signed(31 downto 0);
        R_DATA                            :   OUT   signed(31 downto 0)
        );
    end component;

  -- Signals
	signal read_address_re                : std_logic_vector(12 downto 0);
    signal write_address_re               : std_logic_vector(11 downto 0);
    signal write_en_re                    : std_logic;
    signal write_data_re                  : signed(31 downto 0);
    signal read_data_re                   : signed(31 downto 0);
    signal read_address_im                : std_logic_vector(12 downto 0);
    signal write_address_im               : std_logic_vector(11 downto 0);
    signal write_en_im                    : std_logic;
    signal write_data_im                  : signed(31 downto 0);
    signal read_data_im                   : signed(31 downto 0);
    
    signal fft_valid_s                    : std_logic;
    signal fft_val_re_s                   : signed(31 downto 0);
    signal fft_val_im_s                   : signed(31 downto 0);
    signal fft_val_re_s1                  : signed(32 downto 0);
    signal fft_val_re_s2                  : signed(32 downto 0);
    signal fft_val_re_s3                  : signed(32 downto 0);
    signal fft_val_im_s1                  : signed(31 downto 0);

    signal count                          : integer range 0 to 4095;
    signal bin_s1                         : integer range 0 to 4096;
    signal bin_s2                         : integer range 0 to 4096;
    signal bin_s3                         : integer range 0 to 4096;
    signal bin_s4                         : integer range 0 to 4096;
    signal bin_s5                         : integer range 0 to 4096;

    signal fft_val_im_resize              : signed(32 downto 0);
    signal fft_val_im_neg                 : signed(32 downto 0);
    signal fft_val_im_conj                : signed(32 downto 0);
    signal fft_val_im_conj_s1             : signed(32 downto 0);

    signal ready_s1                       : std_logic;
    signal ready_s2                       : std_logic;
    signal ready_s3                       : std_logic;
    signal ready_s4                       : std_logic;
    
    signal fft_val_b_re                   : signed(32 downto 0);
    signal fft_val_b_im                   : signed(32 downto 0);

    signal fft_val_sum_re                 : signed(32 downto 0);
    signal fft_val_sum_im                 : signed(32 downto 0);
    signal fft_val_dif_re                 : signed(32 downto 0);
    signal fft_val_dif_im                 : signed(32 downto 0);

BEGIN
    real_buffer : PF_TPSRAM_C1
    PORT MAP( 
        CLK => clk,
        R_ADDR => read_address_re(10 downto 0),
        W_EN => write_en_re,
        W_ADDR => write_address_re(10 downto 0),
        W_DATA => write_data_re,
        R_DATA => read_data_re
        );
        
    imag_buffer : PF_TPSRAM_C1
    PORT MAP( 
        CLK => clk,
        R_ADDR => read_address_im(10 downto 0),
        W_EN => write_en_im,
        W_ADDR => write_address_im(10 downto 0),
        W_DATA => write_data_im,
        R_DATA => read_data_im
        );

    process (clk)
    begin
    if (rising_edge(clk)) then
        if (reset = '1') then
            write_en_re <= '0';
            write_en_im <= '0';
            write_address_re <= (others=>'0');
            write_address_im <= (others=>'0');
            write_data_re <= (others=>'0');
            write_data_im <= (others=>'0');
            read_address_re <= (others=>'0');
            read_address_im <= (others=>'0');
            count <= 0;
            bin_s1 <= 1;
            bin_s2 <= 0;
            bin_s3 <= 0;
            bin_s4 <= 0;
            bin_s5 <= 0;
            fft_val_b_re <= (others=>'0');
            fft_val_b_im <= (others=>'0');
            ready_s1 <= '0';
            ready_s2 <= '0';
            ready_s3 <= '0';
            ready_s4 <= '0';
            
            fft_valid_s         <= '0';
            fft_val_re_s        <= (others=>'0');
            fft_val_im_s        <= (others=>'0');
            fft_val_re_s1       <= (others=>'0');
            fft_val_re_s2       <= (others=>'0');
            fft_val_re_s3       <= (others=>'0');
            --fft_val_im_s1       <= (others=>'0');
            
            fft_val_im_resize  <= (others=>'0');
            fft_val_im_neg     <= (others=>'0');
            fft_val_im_conj    <= (others=>'0');
            fft_val_im_conj_s1 <= (others=>'0');

            fft_val_sum_re                 <= (others=>'0');
            fft_val_sum_im                 <= (others=>'0');
            fft_val_dif_re                 <= (others=>'0');
            fft_val_dif_im                 <= (others=>'0');
        else
            fft_valid_s <= fft_valid;
            fft_val_re_s <= signed(fft_val_re);
            fft_val_im_s <= signed(fft_val_im);
            if (fft_valid_s = '1') then
                if (count = 4095) then
                    count <= 0;
                else
                    count <= count + 1;
                end if;
            end if;
            
            bin_s1 <= 4095 - count;
            read_address_re <= std_logic_vector(to_unsigned(bin_s1,read_address_re'length));
            read_address_im <= std_logic_vector(to_unsigned(bin_s1,read_address_im'length));
            if (count < 2048) then
                write_address_re <= std_logic_vector(to_unsigned(count + 1,write_address_re'length));
                write_address_im <= std_logic_vector(to_unsigned(count + 1,write_address_im'length));
                write_data_re <= fft_val_re_s;
                write_data_im <= fft_val_im_s;
                if (fft_valid_s = '1') then
                    write_en_re <= '1';
                    write_en_im <= '1';
                else
                    write_en_re <= '0';
                    write_en_im <= '0';
                end if;
                fft_val_b_re <= (others=>'0');
                fft_val_b_im <= (others=>'0');
            else
                write_en_re <= '0';
                write_en_im <= '0';
            end if;
            
            --These operations need to start being done when the incoming fft_valid is high
            --But because of pipelining, they need to continue past when fft_valid goes low
            --To simplify it at this stage, I just have them all running constantly
            fft_val_re_s1 <= resize(fft_val_re_s, 33);
            fft_val_re_s2 <= fft_val_re_s1;
            fft_val_re_s3 <= fft_val_re_s2;
            --fft_val_im_s1 <= fft_val_im_s;
            fft_val_b_re <= resize(read_data_re, 33);
            fft_val_b_im <= resize(read_data_im, 33);
            fft_val_im_resize <= resize(fft_val_im_s, 33);
            fft_val_im_conj <=  - (fft_val_im_resize);
            fft_val_im_conj_s1 <= fft_val_im_conj;
            
            bin_s2 <= bin_s1;
            bin_s3 <= bin_s2;
            bin_s4 <= bin_s3;
            bin_s5 <= bin_s4;
            bin <= std_logic_vector(to_unsigned(bin_s5,bin'length));

            --ch1_val_re <= std_logic_vector(fft_val_b_re);
            --ch1_val_im <= std_logic_vector(fft_val_b_im);
            
            --ch2_val_re <= std_logic_vector(fft_val_b_re);
            --ch2_val_im <= std_logic_vector(fft_val_b_im);
            
            --ch1_val = 0.5*(fft_val_b+conj(fft_val));
            --ch2_val = complex(0,-0.5)*(fft_val_b-conj(fft_val));
            --If you do FOIL with the complex multiplication for ch2, you'll see how this shakes out
            --Rather than add another negation I swapped the subtraction order for fft_val_dif_re
            
            --These operations need to start being done when the incoming fft_valid is high
            --But because of pipelining, they need to continue past when fft_valid goes low
            --To simplify it at this stage, I just have them all running constantly
            fft_val_sum_re <= fft_val_b_re + fft_val_re_s3;
            fft_val_sum_im <= fft_val_b_im + fft_val_im_conj_s1;
            fft_val_dif_re <= fft_val_re_s3 - fft_val_b_re;
            fft_val_dif_im <= fft_val_b_im - fft_val_im_conj_s1;
            if ((fft_valid_s = '1') and (count > 2048)) then
                ready_s1 <= '1';
                
            else
                ready_s1 <= '0';
                --fft_val_sum_re <= (others=>'0');
                --fft_val_sum_im <= (others=>'0');
                --fft_val_dif_re <= (others=>'0');
                --fft_val_dif_im <= (others=>'0');
            end if;
            --Complex multiplication means that the ch2 outputs swap becaues it's multiplied by -0.5j
            ch1_val_re <= std_logic_vector(resize(shift_right(fft_val_sum_re, integer(1)), 32));
            ch1_val_im <= std_logic_vector(resize(shift_right(fft_val_sum_im, integer(1)), 32));
            ch2_val_re <= std_logic_vector(resize(shift_right(fft_val_dif_im, integer(1)), 32));
            ch2_val_im <= std_logic_vector(resize(shift_right(fft_val_dif_re, integer(1)), 32));

            ready_s2 <= ready_s1;
            ready_s3 <= ready_s2;
            ready_s4 <= ready_s3;
            ready <= ready_s4;
            ce_out <= ready_s4;
        end if;
    end if;
    end process;

END rtl;
